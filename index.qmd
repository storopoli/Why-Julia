---
title: "Why Julia?"
subtitle: "A gentle pitch"
format:
  revealjs: 
    slide-number: true
    transition: slide
    chalkboard: 
      buttons: false
    preview-links: auto
    footer: <https://storopoli.github.io/CHANGEME>
    callout-appearance: minimal
jupyter: julia-1.8
---

```{julia}
ENV["PYCALL_JL_RUNTIME_PYTHON"] = Sys.which("python")
using PyCall
```

## Agenda

</br>
</br>

::: incremental

1. speed
2. ease-of-use
3. composability
:::

## What I Assume?

</br>
</br>

::: incremental

- Python background
- scientific computing background
:::

## Speed

</br>

::: {.callout-note}

**Julia is fast!**

:::

</br>

::: {.fragment .fade-in}
Two examples:
:::

::: incremental

- Data Wrangling: `pandas` versus `DataFrames.jl`
- ODE solving: `PYTHON` versus `DifferentialEquations.jl`
:::

## Benchmarking --- Data Wrangling

Common data wrangling scenario doing "split-apply-combine" operations.

::: incremental

- 10,000 observations
- 1 categorical variable `x` $\in \{\mathrm{A}, \mathrm{B}, \mathrm{C}, \mathrm{D}\}$
- 2 continuous variables:
  - `y` $\in [0, 1]$
  - `z` $\text{Normal}(0, 1)$
:::

## Benchmarking --- Data Wrangling (Python)

```{julia}
#| echo: true
using BenchmarkTools
py"""
import pandas as pd
import numpy as np
import timeit

n = 10000

df = pd.DataFrame({'x': np.random.choice(['A', 'B', 'C', 'D'], n, replace=True),
                   'y': np.random.randn(n),
                   'z': np.random.rand(n)})
"""
@btime py"df.groupby('x').agg({'y': 'median', 'z': 'mean'})";
```

## Benchmarking --- Data Wrangling (Julia)

```{julia}
#| echo: true
using Random
using DataFrames
using BenchmarkTools
using Chain
Random.seed!(123)

n = 10_000

df = DataFrame(
    x=rand('A':'N', n),
    y=rand(n),
    z=randn(n),
)

@btime @chain $df begin
    groupby(:x)
    combine(:y => median, :z => mean)
end;
```

## Benchmarking --- ODE Solver

## Benchmarking --- ODE Solver (Julia)

## Benchmarking --- ODE Solver (Python)

## Composability
